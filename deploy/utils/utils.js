const { getAllEvents } = require('./datagate');

const expectedTxFinalisationTime = 45000 // 45 sec
const maxWaitTime = 6000000; // 10 minutes in milliseconds
const maxRetries = 3;
const initialBackoff = 30000; // 30 seconds


async function checkTxSuccessWithRetry(txHash, successModuleName, successEventName) {
    console.log(`Checking success of transaction ${txHash}`);

    await new Promise(resolve => setTimeout(resolve, expectedTxFinalisationTime));

    let retries = 0;
    while (retries < maxRetries) {
        const result = await getAllEvents(txHash);
        if (result) {
            // console.log(result);
            for (const event of result) {
                // console.log(event);
                if (event.receipt.event_module === successModuleName && event.receipt.event_name === successEventName) {
                    console.log(`Event ${successModuleName}.${successEventName} confirmed for transaction ${txHash}`);
                    return result;
                }
            }
            throw new Error(`Event ${successModuleName}.${successEventName} not found for transaction ${txHash}`);
        } else {
            retries++;
            if (retries === maxRetries) {
                console.log(`Failed to find the event ${successModuleName}.${successEventName} in tx ${txHash} after ${maxRetries} attempts`);
                throw err;
            }
            const backoffTime = initialBackoff * Math.pow(2, retries - 1);
            console.log(`Couldn't fetch events generated by transaction. Retrying in ${backoffTime}ms. Attempt ${retries} of ${maxRetries}`);
            await new Promise(resolve => setTimeout(resolve, backoffTime));
        }
    }
}

async function processClearingTransaction(signer, ct) {
    return new Promise(async (resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error(`CT processing timed out after ${maxWaitTime}ms`));
        }, maxWaitTime);

        try {
            const txHash = await ct.signAndSend(signer, { nonce: -1 });
            const txEvents = await checkTxSuccessWithRetry(txHash.toString(), "AddressPools", "CTProcessingCompleted");
            console.log(`CT processing completed successfully`);
            // console.log(`Transaction completed successfully with events: ${txEvents}`);
            clearTimeout(timeout);
            resolve(txEvents);
        } catch (error) {
            clearTimeout(timeout);
            console.error("Error in processClearingTransaction:", error);
            reject(error);
        }
    });
}

async function processSignedTransaction(signer, tx) {
    return new Promise(async (resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error(`Transaction timed out after ${maxWaitTime}ms`));
        }, maxWaitTime);

        try {
            const txHash = await tx.signAndSend(signer, { nonce: -1 });
            const txEvents = await checkTxSuccessWithRetry(txHash.toString(), "System", "ExtrinsicSuccess");
            console.log(`Transaction processing completed successfully`);
            // console.log(`Transaction completed successfully with events: ${txEvents}`);
            clearTimeout(timeout);
            resolve(txEvents);
        } catch (error) {
            clearTimeout(timeout);
            console.error("Error in processSignedTransaction:", error);
            reject(error);
        }
    });
}

async function processSignedBatchTransaction(signer, tx) {
    return new Promise(async (resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error(`Batch transaction timed out after ${maxWaitTime}ms`));
        }, maxWaitTime);

        try {
            const txHash = await tx.signAndSend(signer, { nonce: -1 });
            let txEvents = await checkTxSuccessWithRetry(txHash.toString(), "Utility", "BatchCompleted");
            console.log(`Batch transaction processing completed successfully`);
            // console.log(`Transaction completed successfully with events: ${txEvents}`);
            clearTimeout(timeout);
            resolve(txEvents);
        } catch (error) {
            clearTimeout(timeout);
            console.error("Error in processSignedBatchTransaction:", error);
            reject(error);
        }
    });
}


module.exports = {
    processClearingTransaction,
    processSignedTransaction,
    processSignedBatchTransaction
}