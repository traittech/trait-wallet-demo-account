import { SubmittableExtrinsic } from "@polkadot/api/types";
import { KeyringPair } from "@polkadot/keyring/types";
import { ISubmittableResult } from "@polkadot/types/types";
import Pino from "pino";
import { getAllEvents } from "./datagate.js";
import { EventInfo } from "./types";

const expectedTxFinalisationTime = 45000; // 45 sec
const maxWaitTime = 6000000; // 10 minutes in milliseconds
const maxRetries = 3;
const initialBackoff = 30000; // 30 seconds
const logger = Pino();

async function checkTxSuccessWithRetry(txHash: string, successModuleName: string, successEventName: string) {
  logger.debug(`Checking success of transaction ${txHash}`);

  await new Promise((resolve) => setTimeout(resolve, expectedTxFinalisationTime));

  let retries = 0;
  while (retries < maxRetries) {
    const txEvents = await getAllEvents(txHash);
    if (txEvents !== null) {
      // We received list of events generated by the TX.
      // Check if the event, that confirms the success of TX, is present.
      for (const txEvent of txEvents) {
        if (txEvent.receipt.event_module === successModuleName && txEvent.receipt.event_name === successEventName) {
          logger.debug(`Event ${successModuleName}.${successEventName} confirmed for transaction ${txHash}`);
          return txEvents;
        }
      }
      throw new Error(`Event ${successModuleName}.${successEventName} not found for transaction ${txHash}`);
    } else {
      // We didn't receive info about a TX. Wait and try again
      retries++;
      if (retries === maxRetries) {
        logger.error(
          `Failed to find the event ${successModuleName}.${successEventName} in tx ${txHash} after ${maxRetries} attempts`,
        );
        throw new Error();
      }
      const backoffTime = initialBackoff * Math.pow(2, retries - 1);
      logger.debug(
        `Couldn't fetch events generated by transaction. Retrying in ${backoffTime}ms. Attempt ${retries} of ${maxRetries}`,
      );
      await new Promise((resolve) => setTimeout(resolve, backoffTime));
    }
  }

  return [];
}

async function processClearingTransaction(
  signer: KeyringPair,
  ct: SubmittableExtrinsic<"promise", ISubmittableResult>,
): Promise<EventInfo[]> {
  const timeout = setTimeout(() => {
    throw new Error(`CT processing timed out after ${maxWaitTime}ms`);
  }, maxWaitTime);

  try {
    const txHash = await ct.signAndSend(signer, { nonce: -1 });
    const txEvents = await checkTxSuccessWithRetry(txHash.toString(), "AppTransactions", "CTProcessingCompleted");
    logger.info(`CT processing completed successfully`);
    clearTimeout(timeout);
    return txEvents;
  } catch (error) {
    clearTimeout(timeout);
    logger.error(error, "Error in processClearingTransaction");
    throw error;
  }
}

async function processSignedTransaction(
  signer: KeyringPair,
  tx: SubmittableExtrinsic<"promise", ISubmittableResult>,
): Promise<EventInfo[]> {
  const timeout = setTimeout(() => {
    throw new Error(`Transaction timed out after ${maxWaitTime}ms`);
  }, maxWaitTime);

  try {
    const txHash = await tx.signAndSend(signer, { nonce: -1 });
    const txEvents = await checkTxSuccessWithRetry(txHash.toString(), "System", "ExtrinsicSuccess");
    logger.info(`Transaction processing completed successfully`);
    clearTimeout(timeout);
    return txEvents;
  } catch (error) {
    clearTimeout(timeout);
    logger.error(error, "Error in processSignedTransaction");
    throw error;
  }
}

async function processSignedBatchTransaction(
  signer: KeyringPair,
  tx: SubmittableExtrinsic<"promise", ISubmittableResult>,
): Promise<EventInfo[]> {
  const timeout = setTimeout(() => {
    throw new Error(`Batch transaction timed out after ${maxWaitTime}ms`);
  }, maxWaitTime);

  try {
    const txHash = await tx.signAndSend(signer, { nonce: -1 });
    const txEvents = await checkTxSuccessWithRetry(txHash.toString(), "Utility", "BatchCompleted");
    logger.info(`Batch transaction processing completed successfully`);
    clearTimeout(timeout);
    return txEvents;
  } catch (error) {
    clearTimeout(timeout);
    logger.error(error, "Error in processSignedBatchTransaction");
    throw error;
  }
}

export { processClearingTransaction, processSignedBatchTransaction, processSignedTransaction };
